Этот алгоритм заключается в создании хэш-таблицы для хранения элементов первого массива. Затем проходимся по второму массиву и проверяем, есть ли его элементы в хэш-таблице. Если есть, то добавляем элемент в результат. Сложность алгоритма O(m+n), где m и n - размеры массивов.

```javascript
function intersection(arr1, arr2) {
  // создаем объект-хеш для первого массива
  let map = {};
  for (let i = 0; i < arr1.length; i++) {
    map[arr1[i]] = true;
  }

  // создаем массив для результата
  let result = [];

  // проверяем каждый элемент второго массива
  for (let i = 0; i < arr2.length; i++) {
    // если элемент есть в хеше первого массива, то добавляем его в результат
    if (map[arr2[i]]) {
      result.push(arr2[i]);
    }
  }

  return result;
}
```

В этом алгоритме мы двигаем два указателя i и j по отсортированным массивам arr1 и arr2. Если элемент arr1[i] меньше, чем элемент arr2[j], то мы сдвигаем указатель i, так как элементы в arr1 отсортированы по возрастанию и все элементы после arr1[i] также будут меньше, чем arr2[j]. Если элемент arr1[i] больше, чем элемент arr2[j], то мы сдвигаем указатель j. И если элементы равны, то мы добавляем элемент в результирующий массив и двигаем оба указателя.

