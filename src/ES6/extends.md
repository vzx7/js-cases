# Наследование
## В целом
Модель наследования в JavaScript отличается от классической модели наследования, такой как, например, в Java.В JavaScript используется прототипное наследование, которое основывается на объектах, в отличие от классов.

В прототипном наследовании, объекты могут наследовать свойства и методы от других объектов - прототипов.У каждого объекта есть свойство `__proto__`, которое ссылается на его прототип.Если свойство или метод не найден в самом объекте, то интерпретатор JavaScript ищет его в его прототипе и в цепочке прототипов.

В классической модели наследования, классы являются шаблонами для создания объектов.Они определяют свойства и методы, которые будут у всех объектов, созданных из класса.Классы могут наследовать свойства и методы от других классов, образуя иерархию классов.

Кроме того, в JavaScript классы появились только в более поздних версиях языка(начиная с ES6), и даже в этом случае они являются синтаксическим сахаром над существующей прототипной моделью наследования.Таким образом, наследование в JavaScript более гибкое и динамичное, чем в классической модели наследования.

## В классах

Для создания объектов с определенными прототипами в ES6 был добавлен новый синтаксис class, который использует прототипы для наследования. Например, рассмотрим следующий пример:

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Dog extends Animal {
  constructor(name) {
    super(name); // вызов конструктора родителя
  }

  speak() {
    console.log(`${this.name} barks.`);
  }
}

let dog = new Dog('Rex');
dog.speak(); // Rex barks.
```
В этом примере Dog наследует от Animal с помощью ключевого слова extends. Класс Dog также имеет свой собственный конструктор, который вызывает конструктор родительского класса с помощью метода super(). Класс Dog также переопределяет метод speak(), который был унаследован от Animal.

Также в JavaScript существует возможность создания объектов с помощью конструкторов функций. В этом случае прототип наследуется через свойство prototype функции-конструктора. Например

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function() {
  console.log(`${this.name} makes a noise.`);
}

function Dog(name) {
  Animal.call(this, name);
}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.speak = function() {
  console.log(`${this.name} barks.`);
}

let dog = new Dog('Rex');
dog.speak(); // Rex barks.
```

Здесь мы определяем функцию-конструктор Animal и добавляем метод speak() в его прототип. Затем мы определяем функцию-конструктор Dog, которая наследует свойства и методы от Animal через Object.create(). Конструктор Dog также переопределяет метод speak().

## Замена прототипа

```javascript
function Animal() {}
Animal.prototype = Object.create(Array.prototype);
Animal.prototype.constructor = Animal;
```
